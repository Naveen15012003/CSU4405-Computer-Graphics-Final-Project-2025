#include "HUD.h"
#include <iostream>

// 8x8 bitmap font (ASCII 32-127)
// Simplified font data for essential characters
const unsigned char FONT_8x8[96][8] = {
    // Space (32)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // ! (33)
    {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00},
    // " (34)
    {0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00},
    // # (35)
    {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00},
    // $ (36)
    {0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00},
    // % (37)
    {0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00},
    // & (38)
    {0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00},
    // ' (39)
    {0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00},
    // ( (40)
    {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00},
    // ) (41)
    {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00},
    // * (42)
    {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00},
    // + (43)
    {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00},
    // , (44)
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30},
    // - (45)
    {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00},
    // . (46)
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00},
    // / (47)
    {0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00},
    // 0 (48)
    {0x3C,0x66,0x6E,0x7E,0x76,0x66,0x3C,0x00},
    // 1 (49)
    {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00},
    // 2 (50)
    {0x3C,0x66,0x06,0x0C,0x18,0x30,0x7E,0x00},
    // 3 (51)
    {0x7E,0x0C,0x18,0x0C,0x06,0x66,0x3C,0x00},
    // 4 (52)
    {0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00},
    // 5 (53)
    {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00},
    // 6 (54)
    {0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00},
    // 7 (55)
    {0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x00},
    // 8 (56)
    {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00},
    // 9 (57)
    {0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00},
    // : (58)
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00},
    // ; (59)
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30},
    // < (60)
    {0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00},
    // = (61)
    {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00},
    // > (62)
    {0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00},
    // ? (63)
    {0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00},
    // @ (64)
    {0x3C,0x66,0x6E,0x6A,0x6E,0x60,0x3C,0x00},
    // A (65)
    {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00},
    // B (66)
    {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00},
    // C (67)
    {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00},
    // D (68)
    {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00},
    // E (69)
    {0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00},
    // F (70)
    {0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00},
    // G (71)
    {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00},
    // H (72)
    {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00},
    // I (73)
    {0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00},
    // J (74)
    {0x06,0x06,0x06,0x06,0x06,0x66,0x3C,0x00},
    // K (75)
    {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00},
    // L (76)
    {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00},
    // M (77)
    {0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00},
    // N (78)
    {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00},
    // O (79)
    {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    // P (80)
    {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00},
    // Q (81)
    {0x3C,0x66,0x66,0x66,0x6A,0x6C,0x36,0x00},
    // R (82)
    {0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00},
    // S (83)
    {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00},
    // T (84)
    {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00},
    // U (85)
    {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    // V (86)
    {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00},
    // W (87)
    {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00},
    // X (88)
    {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00},
    // Y (89)
    {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00},
    // Z (90)
    {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00},
    // [ (91)
    {0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00},
    // \ (92)
    {0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00},
    // ] (93)
    {0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00},
    // ^ (94)
    {0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00},
    // _ (95)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
    // Remaining characters (96-127) - fill with spaces
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // ` 96
    {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00}, // a 97
    {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00}, // b 98
    {0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00}, // c 99
    {0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00}, // d 100
    {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00}, // e 101
    {0x1C,0x36,0x30,0x7C,0x30,0x30,0x30,0x00}, // f 102
    {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C}, // g 103
    {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00}, // h 104
    {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // i 105
    {0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C}, // j 106
    {0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00}, // k 107
    {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // l 108
    {0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00}, // m 109
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00}, // n 110
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00}, // o 111
    {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60}, // p 112
    {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06}, // q 113
    {0x00,0x00,0x6C,0x76,0x60,0x60,0x60,0x00}, // r 114
    {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00}, // s 115
    {0x30,0x30,0x7C,0x30,0x30,0x36,0x1C,0x00}, // t 116
    {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00}, // u 117
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00}, // v 118
    {0x00,0x00,0x63,0x6B,0x7F,0x3E,0x36,0x00}, // w 119
    {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00}, // x 120
    {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C}, // y 121
    {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00}, // z 122
    {0x0E,0x18,0x18,0x30,0x18,0x18,0x0E,0x00}, // { 123
    {0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // | 124
    {0x70,0x18,0x18,0x0C,0x18,0x18,0x70,0x00}, // } 125
    {0x31,0x6B,0x46,0x00,0x00,0x00,0x00,0x00}, // ~ 126
};

HUD::HUD() : fontTexture(0), textVAO(0), textVBO(0), textShader(0) {}

HUD::~HUD() {
    Cleanup();
}

void HUD::Initialize() {
    CreateFontTexture();
    SetupRenderData();
    textShader = CompileTextShader();
}

void HUD::CreateFontTexture() {
    // Create a texture atlas from the font data (16x6 grid = 96 characters)
    const int charWidth = 8;
    const int charHeight = 8;
    const int atlasWidth = 16 * charWidth;  // 16 characters per row
    const int atlasHeight = 6 * charHeight;  // 6 rows
    
    unsigned char* atlasData = new unsigned char[atlasWidth * atlasHeight];
    memset(atlasData, 0, atlasWidth * atlasHeight);
    
    // Build texture atlas
    for (int i = 0; i < 96; i++) {
        int gridX = i % 16;
        int gridY = i / 16;
        
        for (int y = 0; y < 8; y++) {
            unsigned char byte = FONT_8x8[i][y];
            for (int x = 0; x < 8; x++) {
                if (byte & (0x80 >> x)) {
                    int atlasX = gridX * charWidth + x;
                    int atlasY = gridY * charHeight + y;
                    atlasData[atlasY * atlasWidth + atlasX] = 255;
                }
            }
        }
    }
    
    // Create OpenGL texture
    glGenTextures(1, &fontTexture);
    glBindTexture(GL_TEXTURE_2D, fontTexture);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, atlasWidth, atlasHeight, 0, GL_RED, GL_UNSIGNED_BYTE, atlasData);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    
    delete[] atlasData;
}

void HUD::SetupRenderData() {
    glGenVertexArrays(1, &textVAO);
    glGenBuffers(1, &textVBO);
    
    glBindVertexArray(textVAO);
    glBindBuffer(GL_ARRAY_BUFFER, textVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 6 * 4, NULL, GL_DYNAMIC_DRAW);
    
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), 0);
    
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);
}

unsigned int HUD::CompileTextShader() {
    const char* vertexShaderSource = R"(
        #version 330 core
        layout (location = 0) in vec4 vertex;
        out vec2 TexCoords;
        uniform mat4 projection;
        void main() {
            gl_Position = projection * vec4(vertex.xy, 0.0, 1.0);
            TexCoords = vertex.zw;
        }
    )";
    
    const char* fragmentShaderSource = R"(
        #version 330 core
        in vec2 TexCoords;
        out vec4 color;
        uniform sampler2D text;
        uniform vec3 textColor;
        void main() {
            float alpha = texture(text, TexCoords).r;
            color = vec4(textColor, alpha);
        }
    )";
    
    // Compile vertex shader
    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
    glCompileShader(vertexShader);
    
    // Compile fragment shader
    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
    glCompileShader(fragmentShader);
    
    // Link shaders
    unsigned int shader = glCreateProgram();
    glAttachShader(shader, vertexShader);
    glAttachShader(shader, fragmentShader);
    glLinkProgram(shader);
    
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);
    
    return shader;
}

void HUD::RenderText(const std::string& text, float x, float y, float scale, const glm::vec3& color) {
    glUseProgram(textShader);
    glUniform3f(glGetUniformLocation(textShader, "textColor"), color.x, color.y, color.z);
    glActiveTexture(GL_TEXTURE0);
    glBindVertexArray(textVAO);
    
    // Use orthographic projection (screen coordinates)
    glm::mat4 projection = glm::ortho(0.0f, 800.0f, 0.0f, 600.0f);
    glUniformMatrix4fv(glGetUniformLocation(textShader, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
    
    float xpos = x;
    for (char c : text) {
        if (c < 32 || c > 127) continue;  // Skip invalid characters
        
        int charIndex = c - 32;
        int gridX = charIndex % 16;
        int gridY = charIndex / 16;
        
        // Calculate texture coordinates
        float texX = gridX / 16.0f;
        float texY = gridY / 6.0f;
        float texW = 1.0f / 16.0f;
        float texH = 1.0f / 6.0f;
        
        float w = 8.0f * scale;
        float h = 8.0f * scale;
        
        float vertices[6][4] = {
            { xpos,     y + h,   texX,         texY },
            { xpos,     y,       texX,         texY + texH },
            { xpos + w, y,       texX + texW,  texY + texH },
            
            { xpos,     y + h,   texX,         texY },
            { xpos + w, y,       texX + texW,  texY + texH },
            { xpos + w, y + h,   texX + texW,  texY }
        };
        
        glBindTexture(GL_TEXTURE_2D, fontTexture);
        glBindBuffer(GL_ARRAY_BUFFER, textVBO);
        glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        
        glDrawArrays(GL_TRIANGLES, 0, 6);
        
        xpos += w;
    }
    
    glBindVertexArray(0);
    glBindTexture(GL_TEXTURE_2D, 0);
}

void HUD::Cleanup() {
    if (fontTexture) glDeleteTextures(1, &fontTexture);
    if (textVAO) glDeleteVertexArrays(1, &textVAO);
    if (textVBO) glDeleteBuffers(1, &textVBO);
    if (textShader) glDeleteProgram(textShader);
}
